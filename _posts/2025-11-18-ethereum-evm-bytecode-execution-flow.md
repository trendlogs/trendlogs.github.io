---
id: 210
title: '이더리움 EVM 바이트코드 실행 흐름 예시'
date: '2025-11-18T16:30:00+00:00'
author: '김 윤호'
layout: post
guid: 'https://trendlogs.net/?p=210'
permalink: /ethereum-evm-bytecode-execution-flow/
categories:
    - 금융
    - 암호화폐
tags:
    - EVM
    - EVM동작원리
    - Solidity
    - 가스비
    - 바이트코드
    - 블록체인개발
    - 스마트컨트랙트
    - 오퍼코드
    - 이더리움
    - 트랜잭션처리
---

```
0x60 02      // PUSH1 0x02
0x60 03      // PUSH1 0x03
0x01         // ADD
0x60 00      // PUSH1 0x00
0x52         // MSTORE
0x60 20      // PUSH1 0x20
0x60 00      // PUSH1 0x00
0xf3         // RETURN
```

이 코드는 “2 + 3 = 5” 계산 후, 그 결과(5)를 메모리 0x00 위치에 저장하고 32바이트를 반환하는 구조다. 바이트코드 학습에서 가장 기본적인 예시다.

---

## 1단계: 프로그램 카운터 초기화

EVM은 PC(program counter)를 0으로 설정하고 시작한다.  
스택, 메모리, 스토리지 모두 비어 있는 상태이고, 트랜잭션에서 제공된 가스를 소유한 채로 실행이 개시된다.

---

## 2단계: PUSH1 0x02 (0x60 02)

- PC = 0
- 오퍼코드 `0x60` → PUSH1
- 바로 뒤 1바이트 값(0x02)을 스택에 push
- 스택 상태: `[2]`
- PC는 PUSH1(1바이트) + 즉시값(1바이트) 만큼 증가하여 PC = 2

---

## 3단계: PUSH1 0x03 (0x60 03)

- PC = 2
- 오퍼코드 `0x60` → PUSH1
- 즉시값 0x03 push
- 스택: `[2, 3]`
- PC = 4

---

## 4단계: ADD (0x01)

- PC = 4
- 오퍼코드 `0x01` → ADD
- 스택 top 두 개 pop: 3, 2
- 더한 값 5를 push
- 스택: `[5]`
- PC = 5

---

## 5단계: PUSH1 0x00 (0x60 00)

- PC = 5
- 오퍼코드 `0x60` → PUSH1
- 즉시값 0x00 push
- 스택: `[5, 0]`
- PC = 7

---

## 6단계: MSTORE (0x52)

- PC = 7
- 오퍼코드 `0x52` → MSTORE
- 스택에서 주소와 값을 pop
    - 주소 = 0
    - 값 = 5
- 메모리 0번지부터 32바이트 공간에 “5”를 32바이트로 패딩하여 저장
- 메모리: `[00~1f] = 0x0000000000000000000000000000000000000000000000000000000000000005`
- PC = 8

---

## 7단계: PUSH1 0x20 (0x60 20)

- PC = 8
- 오퍼코드 `0x60` → PUSH1
- 즉시값 0x20 push
- 스택: `[32]`
- PC = 10

---

## 8단계: PUSH1 0x00 (0x60 00)

- PC = 10
- 오퍼코드 `0x60` → PUSH1
- 즉시값 0x00 push
- 스택: `[32, 0]`
- PC = 12

---

## 9단계: RETURN (0xf3)

- PC = 12
- 오퍼코드 `0xf3` → RETURN
- 스택에서 pop
    - offset = 0
    - size = 32
- 메모리\[offset : offset+size\] 구간을 반환 데이터로 지정
- 즉, 0x00~0x1f 범위의 32바이트를 반환
- 결과 = `0x0000000000000000000000000000000000000000000000000000000000000005`

여기서 실행이 종료된다.  
EVM은 반환한 32바이트 값을 호출자에게 전달한다.

---

## 이 예시가 의미하는 것

- EVM은 오로지 스택 기반으로 동작한다.
- PC는 명령어 길이만큼 정확히 이동한다.
- 메모리(Memory)는 실행 중에만 존재하며, RETURN이 지정한 범위가 결과가 된다.
- 오퍼코드 하나하나가 스택을 조작하는 형태로 전체 로직을 유기적으로 구성한다.

한마디로 요약하면, EVM은 “스택 계산 → 메모리 저장 → 범위 반환”이라는 단순한 논리의 반복이다.  
언뜻 단순하지만, 복잡한 스마트 계약도 이 원리 위에서만 움직인다.